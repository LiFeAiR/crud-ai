# Архитектурные решения для упрощения запросов к правам пользователей и организаций

На основе анализа текущей системы были выявлены следующие проблемы с SQL-запросами:

1. **Сложные джоины**: Запросы содержат множество LEFT JOIN, что может приводить к плохой производительности при увеличении объема данных
2. **Безиндексное чтение**: При отсутствии подходящих индексов запросы выполняются медленно
3. **Высокая нагрузка на чтение**: При увеличении читающей нагрузки наблюдаются просадки latency

## Предлагаемые архитектурные решения:

### 1. Решение через Kafka (как уже описано в ADR)
- **Описание**: Оставить только таблицу user_permissions, а все добавления/удаления прав кидать в Kafka
- **Читающий консьюмер**: Физически добавляет или удаляет право в таблице user_permissions
- **Преимущества**:
    - Редкие события по сравнению с читающим трафиком
    - Не будет просадок latency
    - Легко масштабируется
- **Недостатки**:
    - Сложность в реализации
    - Необходимость поддержки Kafka
    - Дополнительная сложность в логировании метаинформации

### 2. Кэширование на уровне приложения
- **Описание**: Использовать Redis или аналогичный кэш для хранения набора прав пользователей
- **Механизм**: При изменении прав обновлять кэш, при чтении использовать кэшированные данные
- **Преимущества**:
    - Простота реализации
    - Высокая скорость чтения
    - Хорошо масштабируется
- **Недостатки**:
    - Необходимость синхронизации кэша
    - Дополнительные затраты на хранение

### 3. Денормализация данных с периодическим обновлением
- **Описание**: Создать отдельную таблицу с денормализованными данными прав пользователей
- **Механизм**: Периодическое обновление таблицы через фоновые задачи
- **Преимущества**:
    - Простые и быстрые запросы
    - Хорошая производительность
- **Недостатки**:
    - Задержка синхронизации
    - Сложность поддержки целостности данных

### 4. Использование Materialized Views
- **Описание**: Создать материализованные представления для часто используемых запросов
- **Механизм**: Периодическое обновление материализованных представлений
- **Преимущества**:
    - Высокая производительность
    - Простота использования
- **Недостатки**:
    - Задержка обновления
    - Сложность управления обновлениями

### 5. Комбинированное решение с брокером сообщений
- **Описание**: Использовать комбинацию кэширования и Kafka для оптимального баланса
- **Механизм**:
    - Быстрое чтение из кэша
    - Асинхронное обновление через Kafka
    - Резервное обновление через фоновые задачи

## Оценка влияния решений:

### Решение через Kafka (ADR)
- **Влияние на производительность**: Значительно улучшает читающую нагрузку
- **Влияние на сложность**: Увеличивается сложность системы
- **Влияние на масштабируемость**: Улучшается
- **Влияние на поддержку**: Увеличивается необходимость в мониторинге Kafka

### Кэширование на уровне приложения
- **Влияние на производительность**: Улучшает скорость чтения
- **Влияние на сложность**: Умеренная сложность
- **Влияние на масштабируемость**: Хорошо масштабируется
- **Влияние на поддержку**: Умеренная сложность

### Денормализация данных
- **Влияние на производительность**: Улучшает производительность запросов
- **Влияние на сложность**: Увеличивается сложность поддержки целостности
- **Влияние на масштабируемость**: Хорошо масштабируется
- **Влияние на поддержку**: Увеличивается сложность

## Рекомендация:

Рекомендую реализовать **комбинированное решение**, которое сочетает преимущества нескольких подходов:

1. **Основной подход**: Использовать кэширование на уровне приложения для быстрого чтения
2. **Асинхронное обновление**: Использовать Kafka для синхронизации кэша при изменениях
3. **Резервный механизм**: Добавить периодическую синхронизацию через фоновые задачи

Это обеспечит лучший баланс между производительностью, простотой поддержки и масштабируемостью.